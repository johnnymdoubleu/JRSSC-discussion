## FIT SUM-PARETO BROWN-RESNICK PROCESS
library(mvPot)
library(cubature)
library(Pareto)
library(parallel)
library(evd)

ncores <- 8
cl <- makeCluster(ncores)

set.seed(5)

n <- 500

# define semivariogram, locations (x), and simulate data (y)

svar <- function(x1_x2, theta = c(0.5, 1))
  
  (norm(x1_x2, type = "2") / (theta[1]))^theta[2]

x <- expand.grid(seq(0,1,length=3),seq(0,1,length=3))

K <- dim(x)[1]

y <- simulPareto(n, x, svar)

sums <- sapply(y, sum)

exceedances <- y[sums > quantile(sums, 0.9)]



# negative log-likelihood

nllh <- function(theta) {
  
  aux <- function(x1_x2)
    
    svar(x1_x2, theta)
  
  # impose parametric constraints via penalization
  
  ifelse(theta[1] > 0 & theta[2] > 0 & theta[2] < 2,
         
         spectralLikelihood(exceedances, x, aux)[1],
         
         10^10)
  
}

opt <- optim(c(.5, .5), nllh, method = "BFGS")$par
cat(opt, "Initialisation with only observed data")
theta0 <- c(opt[1], opt[2])

# recall the true values are (0.2, 1.8)


missing.data <- y
n.locs = nrow(x)
for(i in 1:length(missing.data)){
  missing.data[[i]]=missing.data[[i]]*(rbinom(n.locs,1,prob=0.75))
  missing.data[[i]][missing.data[[i]]==0]=NA
}

means <- sapply(missing.data, mean, na.rm=T)

missing.exceedances <- missing.data[means > quantile(means, 0.9, na.rm=T)]


##########################################################################
nllh <- function(y,x,theta) {
  
  aux <- function(x1_x2)
    
    svar(x1_x2, theta)
  
  # impose parametric constraints via penalization
  
  ifelse(theta[1] > 0 & theta[2] > 0 & theta[2] < 2,
         spectralLikelihood(y, x, aux)[1], 1e10)
}
#changed name due to confusion in the function call for spectralLiklihood()
spectralLik <- function (obs, loc, vario, nCores = 1L, cl = NULL){
  if (is.matrix(obs)) {
    obs <- split(obs, row(obs))
  }
  if (!inherits(obs, "list") || length(obs) < 1 || !inherits(obs[[1]], 
                                                             c("numeric", "integer"))) {
    stop("obs must be a list of vectors")
  }
  if (!inherits(loc, c("matrix", "data.frame"))) {
    stop("`loc` must be a data frame of coordinates as generated by `expand.grid()` or a matrix of locations (one site per row)")
  }
  if (!is.numeric(nCores) || nCores < 1) {
    stop("`nCores` must a positive number of cores to use for parallel computing.")
  }
  if (nCores > 1 && !inherits(cl, "cluster")) {
    stop("For parallel computation, `cl` must an cluster created by `makeCluster` of the package `parallel`.")
  }
  n <- length(obs)
  dim <- nrow(loc)
  if (dim != length(obs[[1]])) {
    stop("The size of the vectors of observations does not match the grid size.")
  }
  gamma <- tryCatch({
    dists <- lapply(1:ncol(loc), function(i) {
      outer(loc[, i], loc[, i], "-")
    })
    computeVarMat <- sapply(1:length(dists[[1]]), function(i) {
      h <- rep(0, ncol(loc))
      for (j in 1:ncol(loc)) {
        h[j] = dists[[j]][i]
      }
      vario(h)
    })
    matrix(computeVarMat, dim, dim)
  }, warning = function(war) {
    war
  }, error = function(err) {
    stop("The semi-variogram is not valid for the locations provided.")
  })
  psi <- (outer(gamma[-1, 1], gamma[-1, 1], "+") - (gamma[-1, 
                                                          -1]))
  invPsi <- MASS::ginv(psi)
  productCovMatrix = function(i) {
    omega <- log(obs[[i]][-1]/obs[[i]][1]) + gamma[-1, 1]
    res <- t(omega) %*% invPsi %*% omega
  }
  if (nCores > 1) {
    likelihood <- parallel::parLapply(cl, 1:n, productCovMatrix)
  }
  else {
    likelihood <- lapply(1:n, productCovMatrix)
  }
  logdetA = determinant(psi, logarithm = TRUE)$modulus
  (1/2 * logdetA + 1/2 * unlist(likelihood))
}

# theta0 <- c(0.5, 1)
theta.star <- theta0
diff <- 1
sample <- matrix(rPareto(8*1e4, 1, 1), ncol=8)-1
while(diff> 1e-3){
  Q <- function(theta, theta.star, missing.exceedances, x){
    n.exceed=length(missing.exceedances)
    if(theta[1] <= 0 | theta[2] <= 0 | theta[2] >= 2) return(1e30)
    if(theta.star[1] <= 0 | theta.star[2] <= 0 | theta.star[2] >= 2) return(1e30)
    Q.out <-0
    
    for(i in 1:n.exceed){
      ind.miss=which(is.na(missing.exceedances[[i]]))
      obs.x=x[-ind.miss,]
      obs.y=missing.exceedances[[i]][-ind.miss]
      if(length(ind.miss)==0){
        Q.out=Q.out-nllh(list(missing.exceedances[[i]]),x,theta)
        # print(i)
        # print(-nllh(list(missing.exceedances[[i]]),x,theta))
      }
      else{
        # integrand=function(input){
        #    y=missing.exceedances[[i]]
        #   y[ind.miss]=input
        #    out = -nllh(list(y),x,theta)*(exp(-nllh(list(y),x,theta.star)))
        # if(any(input<=0)) return(0)
        #  return(out)
        # }
        
        # integral = cubature::cubintegrate(integrand, lower=rep(0,length(ind.miss)), upper = rep(Inf,length(ind.miss)))$integral
        y=apply(as.matrix(sample[,1:length(ind.miss)]),1,function(input){
          out=missing.exceedances[[i]]
          out[ind.miss]=input
          out
        }, simplify=F)
        aux <- function(x1_x2){
          svar(x1_x2, theta)
        }
        aux2 <- function(x1_x2){
          svar(x1_x2, theta.star)
        }
        # -spectralLikelihood(y,x,aux)*(exp(-spectralLikelihood(y,x,aux2)))
        # integral = mean(-spectralLik(y,x,aux)*(exp(-spectralLik(y,x,aux2)))/apply(as.matrix(sample[,1:length(ind.miss)]^{-2}-1),1,prod))
        integral <- mean(-spectralLik(y,x,aux,nCores=ncores,cl=cl)*(exp(-spectralLik(y,x,aux2,nCores = ncores,cl=cl)))/apply(apply(as.matrix(sample[,1:length(ind.miss)]),2,function(x) dgev(x,1,1,1)), 1, prod))
        # print(i)
        # print("missing")
        # print((integral/exp(-nllh(list(obs.y),obs.x,theta.star))))
      }
    }
    return(-Q.out)
  }
  
  # Q(theta0,theta.star,missing.exceedances,x)
  opt <- optim(par = theta.star, 
               fn = Q,
               theta.star = theta.star,
               missing.exceedances = missing.exceedances,
               x = x)
  print(opt$par)
  theta.old <- theta.star
  theta.star <- c(opt$par[1], opt$par[2])
  diff <- sum(abs(theta.star - theta.old))
}
# theta.star=opt$par
# opt=optim(theta0,Q,theta.star=theta.star,missing.exceedances=missing.exceedances,x=x)



